# AUTOGENERATED! DO NOT EDIT! File to edit: 00_utils.ipynb (unless otherwise specified).

__all__ = ['display_image_tensor', 'display_detection_window_waveform', 'df_subset_rows', 'get_annotation_length',
           'find_longest_annotations']

# Cell
import numpy as np
import pandas as pd
import librosa
import matplotlib.pyplot as plt

# Cell
# ignore librosa pysoundfile load warning
import warnings
warnings.filterwarnings(action='ignore', category=UserWarning, module=r'librosa')

# Cell
def display_image_tensor(x, figsize=None, savename=None):
    xn = x.numpy() if len(x.shape)==3 else x.numpy()[0] # handles single-item batches and item-only tensors
    xn = np.moveaxis(xn, 0, 2)
    xn = xn + abs(xn.min()) if xn.min() < 0.0 else xn
    xn /= xn.max()
    if figsize: plt.figure(figsize=(figsize))
    plt.imshow(xn)
    if savename != None: plt.imsave(savename, xn)
    return xn

def display_detection_window_waveform(rec_id,csv_fpath,audio_path,codec='flac',figsize=(20,10)):
    # load
    wf,sr = librosa.load(audio_path/f'{rec_id}.{codec}', sr=None)
    csv_file = pd.read_csv(csv_fpath)
    t_min,t_max = csv_file.loc[csv_file['recording_id']==rec_id].loc[:,['t_min','t_max']].values[0]
    # full waveform
    plt.figure(figsize=figsize)
    plt.axvline(x=int(sr*t_min), color='r'); plt.axvline(x=int(sr*t_max), color='r')
    plt.title(f'{audio_path.name} waveform')
    plt.plot(wf)
    # zoomed waveform
    plt.figure(figsize=(20,10))
    plt.title(f'{audio_path.name} detection')
    plt.plot(wf[int(sr*t_min):int(sr*t_max)], linewidth=0.5)

# Cell
# export
def df_subset_rows(df, column_str, checklist):
    """
    Returns a copied subset of a dataframe with rows where `column_str` matches items in `checklist`.
    """
    dfsubset = pd.DataFrame(columns=df.columns)
    for check in checklist: dfsubset = dfsubset.append(df.loc[df[column_str]==check], ignore_index=True)
    return dfsubset


def get_annotation_length(csv_file, rec_id):
    t_min,t_max = csv_file.loc[csv_file['recording_id']==rec_id].loc[:,['t_min','t_max']].values[0]
    return t_max - t_min


def find_longest_annotations(csv_file, n=1):
    """
    Find length and row-index of the N longest annotation windows.
    """
    l_dict = {}
    for rdx in range(len(csv_file)):
        t_min,t_max = csv_file.iloc[rdx].loc[['t_min','t_max']]
        l = t_max - t_min
        l_dict[rdx] = l
    return sorted(list(l_dict.items()), key=lambda x: x[1], reverse=True)[:n]